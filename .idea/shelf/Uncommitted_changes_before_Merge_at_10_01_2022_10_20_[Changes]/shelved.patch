Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># подключения к необходимым библиотекам\r\nimport sqlite3\r\nimport sys\r\nimport time\r\nimport csv\r\nimport datetime\r\nfrom random import choice, randint\r\nfrom project import Ui_MainWindow\r\nfrom res_dialog import Ui_Dialog\r\nfrom recordings_window import Ui_Form\r\nfrom PyQt5.QtWidgets import QDialog, QInputDialog, QMessageBox\r\nfrom PyQt5.QtWidgets import QApplication, QMainWindow, QWidget, QTableWidgetItem\r\nfrom PyQt5.QtCore import QTimer, Qt\r\nfrom PyQt5 import QtCore, QtWidgets\r\nfrom PyQt5.QtGui import QTextCursor, QPixmap\r\n\r\n# адаптация к экранам с высоким разрешением (HiRes)\r\nif hasattr(QtCore.Qt, 'AA_EnableHighDpiScaling'):\r\n    QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling, True)\r\n\r\nif hasattr(QtCore.Qt, 'AA_UseHighDpiPixmaps'):\r\n    QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_UseHighDpiPixmaps, True)\r\n\r\n\r\n# константы\r\nDATABASE = \"data\\\\trainer_db.db\"\r\n\r\nGREEN = '#49DC01'\r\nRED = '#DC143C'\r\nGRAY1 = \"#383838\"\r\nGRAY2 = \"#7a7a7a\"\r\nYELLOW = \"#f0df1c\"\r\nBLUE = \"#0e46ff\"\r\n\r\nOCEAN_GREEN = \"#6fffeb\"\r\nOCEAN_BLUE = \"#304cff\"\r\nOCEAN_RED = \"#f3633f\"\r\nOCEAN_YELLOW = \"#ffcb52\"\r\n\r\nPURPLE = \"#1b0051\"\r\n\r\nPASTEL_BLUE = \"#b5ebf3\"\r\nPASTEL_PURPLE = \"#4343ca\"\r\nPASTEL_GREEN = \"#a0e546\"\r\nPASTEL_RED = \"#ff8091\"\r\n\r\nGLAMOUR_PINK = \"#ff7ef4\"\r\nGLAMOUR_GRAY = \"#787878\"\r\nGLAMOUR_BLUE = \"#32f7f0\"\r\nGLAMOUR_RED = \"#ff0000\"\r\n\r\nFOREST_GREEN = \"#6caa33\"\r\nFOREST_BROWN = \"#81593e\"\r\nFOREST_LIGHT_GREEN = \"#ebffb4\"\r\nFOREST_RED = \"#d03739\"\r\n\r\n\r\nclass RecordingsWindow(QWidget, Ui_Form):\r\n    def __init__(self, user, theme):\r\n        super().__init__()  # конструктор родительского класса\r\n        # Вызываем метод для загрузки интерфейса из класса Ui_MainWindow,\r\n        self.setupUi(self)\r\n\r\n        self.con = sqlite3.connect(DATABASE)\r\n        self.user = user\r\n\r\n        self.titles = ['record_id', 'user', 'data', 'text', 'mode', 'time', 'typing_speed']\r\n        self.columns = ['record_id', 'user_id', 'data', 'text_id', 'difficulty_id', 'time', 'typing_speed']\r\n\r\n        self.change_theme(theme)  # устанавливаем тему\r\n        self.username_labe.setText(self.user)  # устанавливаем пользователя\r\n        self.load_table()  # заргужаем таблицу\r\n        self.delete_btn.clicked.connect(self.delete_elem)\r\n        self.pushButton.clicked.connect(self.show_dialog)\r\n\r\n    def load_table(self):\r\n        # Создание курсора\r\n        cur = self.con.cursor()\r\n\r\n        # получаем данные из бд путем запроса\r\n        result = cur.execute(f\"\"\"\r\n        SELECT {', '.join(self.columns)} FROM Recordings\r\n            WHERE user_id=(\r\n        SELECT user_id FROM Users WHERE nickname='{self.user}')\r\n        \"\"\").fetchall()\r\n\r\n        # устанавливаем имена столбцов и количество рядов, столбцов\r\n        self.recordings_table.setColumnCount(len(self.titles))\r\n        self.recordings_table.setHorizontalHeaderLabels(self.titles)\r\n        self.recordings_table.setRowCount(len(result))\r\n\r\n        # перебираем элементы\r\n        for i, row in enumerate(result):\r\n            for j, col in enumerate(row):\r\n                # подменяем элемент с id на его значение\r\n                if self.columns[j] == 'user_id':\r\n                    col = self.user\r\n                elif self.columns[j] == 'text_id':\r\n                    que = f\"\"\"\r\n                    SELECT text FROM Texts\r\n                        WHERE text_id={col}\"\"\"\r\n\r\n                    col = cur.execute(que).fetchall()[0][0]\r\n\r\n                elif self.columns[j] == 'difficulty_id':\r\n                    que = f\"\"\"\r\n                    SELECT mode FROM Difficults\r\n                        WHERE difficulty_id={col}\"\"\"\r\n\r\n                    col = cur.execute(que).fetchall()[0][0]\r\n\r\n                # загружаем элемент\r\n                self.recordings_table.setItem(i, j, QTableWidgetItem(str(col)))\r\n\r\n        # делаем таблицу нередактируемой\r\n        self.recordings_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)\r\n\r\n    def delete_elem(self):\r\n        # Получаем список элементов без повторов и их id\r\n        rows = list(set([i.row() for i in self.recordings_table.selectedItems()]))\r\n        ids = [self.recordings_table.item(i, 0).text() for i in rows]\r\n        # Спрашиваем у пользователя подтверждение на удаление элементов\r\n        valid = QMessageBox.question(\r\n            self, '', \"Действительно удалить элементы с id \" + \",\".join(ids),\r\n            QMessageBox.Yes, QMessageBox.No)\r\n        # Если пользователь ответил утвердительно, удаляем элементы.\r\n        # Не забываем зафиксировать изменения\r\n        if valid == QMessageBox.Yes:\r\n            cur = self.con.cursor()\r\n            cur.execute(\"DELETE FROM Recordings WHERE record_id IN (\" + \", \".join(\r\n                '?' * len(ids)) + \")\", ids)\r\n            self.con.commit()\r\n        self.load_table()\r\n\r\n    # функция смены темы\r\n    def change_theme(self, theme):\r\n        pass\r\n\r\n    def show_dialog(self):\r\n        # вызов диалогового окна\r\n        filename, ok_pressed = QInputDialog.getText(self, \"Регистрация\", \"Введите имя файла:\")\r\n        # если пользователь нажал на ОК, то конвертируем результат в csv файл\r\n        if ok_pressed:\r\n            self.convert_to_csv(filename)\r\n\r\n    # функция конвертирования в csv файл\r\n    def convert_to_csv(self, filename):  # в функцию передаем имя файла\r\n        # Создание курсора\r\n        cur = self.con.cursor()\r\n\r\n        # получаем данные из бд путем запроса\r\n        result = cur.execute(f\"\"\"\r\n            SELECT {', '.join(self.columns)} FROM Recordings\r\n                WHERE user_id=(\r\n            SELECT user_id FROM Users WHERE nickname='{self.user}')\"\"\").fetchall()\r\n\r\n        with open(filename, 'w+', newline='') as csv_file:  # открываем файл, если он есть, а иначе создаем его\r\n            writer = csv.DictWriter(\r\n                csv_file, fieldnames=self.titles,\r\n                delimiter=';', quoting=csv.QUOTE_NONNUMERIC)  # объект для записи (writer)\r\n            writer.writeheader()  # пишем заголовок titles\r\n            # запись в csv файл\r\n            for elem in result:\r\n                # создаем словарь\r\n                dictionary = {}\r\n                for j, value in enumerate(elem):\r\n                    key = self.titles[j]\r\n                    # подменяем элемент с id на его значение\r\n                    if self.columns[j] == 'user_id':\r\n                        value = self.user\r\n                    elif self.columns[j] == 'text_id':\r\n                        que = f\"\"\"\r\n                            SELECT text FROM Texts\r\n                                WHERE text_id={value}\"\"\"\r\n\r\n                        value = cur.execute(que).fetchall()[0][0]\r\n\r\n                    elif self.columns[j] == 'difficulty_id':\r\n                        que = f\"\"\"\r\n                            SELECT mode FROM Difficults\r\n                                WHERE difficulty_id={value}\"\"\"\r\n\r\n                        value = cur.execute(que).fetchall()[0][0]\r\n\r\n                    # присваеваем значение к ключу\r\n                    dictionary[key] = value\r\n\r\n                writer.writerow(dictionary)\r\n\r\n    # функция, которая вызывается, когда закрывается окно\r\n    def closeEvent(self, *args, **kwargs):\r\n        # Закрытие соединение с базой данных при закрытие окна\r\n        self.con.close()\r\n\r\n\r\n# Наследуемся от виджета из PyQt5.QtWidgets и от класса с интерфейсом\r\nclass MyWidget(QMainWindow, Ui_MainWindow):\r\n    def __init__(self):\r\n        super().__init__()\r\n        # Вызываем метод для загрузки интерфейса из класса Ui_MainWindow,\r\n        self.setupUi(self)\r\n\r\n        # связываемся с базой данных trainer_db.db\r\n        self.con = sqlite3.connect(DATABASE)\r\n\r\n        self.difficulty_mode = 'easy'  # легкий режим по умолчанию\r\n        self.load_users()\r\n        self.user = \"Гость\"  # пользователь по умолчанию\r\n\r\n        self.theme = \"dark\"  # тема по умолчанию\r\n        self.interface_binding()  # привязка частей интерфейса к функциям\r\n\r\n        self.is_program_change = False  # переменная для отслеживания изменения программой текста\r\n        self.is_stopwatch_start = False  # переменная для отслеживания начало старта секундомера\r\n\r\n        # Создание секундомера\r\n        self.stopwatch = QTimer(self)\r\n        self.stopwatch.timeout.connect(self.show_stopwatch)\r\n        self.start_time = 0  # время начало ввода\r\n        self.timeInterval = 100  # интервал вызова секундомера\r\n        self.time_r = 0  # разница между начальным временем и текущем временем. Изначально равен 0\r\n\r\n        # при изменении текста в entered_text вызвать функцию text_changed\r\n        self.entered_text.textChanged.connect(self.text_changed)\r\n        # цвет для выделения правильного текста и неправильного текста\r\n        self.correct_color = GREEN\r\n        self.incorrect_color = RED\r\n\r\n        self.load_text(self.difficulty_mode)\r\n\r\n    # обработчик событий нажатия клавиш и мыши\r\n    def keyPressEvent(self, event):\r\n        if event.key() == Qt.Key_Escape:  # при нажатие на esc начать заново\r\n            self.start_again()\r\n\r\n    # начать заново ввод текста\r\n    def start_again(self):\r\n        self.is_program_change = True  # программа изменила текст\r\n        self.reset_stopwatch()  # перезапустить секундомер\r\n        self.load_text(self.difficulty_mode)\r\n        self.entered_text.setText(\"\")  # обнулить вводимый текст\r\n        self.is_program_change = False  # вернуться к исходному значению\r\n\r\n    # загрузка нового текста со сложностью difficult из таблицы Texts\r\n    def load_text(self, difficult):\r\n        # Создание курсора\r\n        cur = self.con.cursor()\r\n\r\n        # Выполнение запроса и получение всех результатов\r\n        texts = cur.execute(f\"\"\"\r\n        SELECT text FROM Texts \r\n            WHERE difficulty_id=(\r\n        SELECT difficulty_id FROM Difficults \r\n            WHERE mode = '{difficult}')\r\n        \"\"\").fetchall()\r\n\r\n        # выбирание случайного текста, пока он совпадает с текстом в generated_text\r\n        text = choice(texts)[0]\r\n        while self.generated_text.text() == text:\r\n            text = choice(texts)[0]\r\n        self.generated_text.setText(text)  # вставить новой текст в generated_text\r\n\r\n    # обработчик события изменения текста\r\n    def text_changed(self):\r\n        if not self.is_program_change:\r\n            if not self.is_stopwatch_start:  # если таймер был не запущен, запустить его\r\n                self.start_stopwatch()\r\n            self.compare_texts()\r\n\r\n    # функция сравнения текстов из generated_text и entered_text\r\n    def compare_texts(self):\r\n        cursor = self.entered_text.textCursor()\r\n        font_size = 4\r\n        is_correct = True\r\n        generated_text = self.generated_text.text()\r\n        entered_text = self.entered_text.toPlainText()\r\n        html = \"\"\r\n        for index, character in enumerate(entered_text):\r\n            if index <= len(generated_text) - 1:\r\n                if generated_text[index] != character:\r\n                    is_correct = False\r\n            else:\r\n                is_correct = False\r\n            color = self.correct_color if is_correct else self.incorrect_color\r\n            html += f\"<font color='{color}' size = {font_size} >{character}</font>\"\r\n        self.is_program_change = True\r\n        self.entered_text.setHtml(html)\r\n        self.is_program_change = False\r\n        self.entered_text.setTextCursor(cursor)\r\n        if is_correct and len(entered_text) == len(generated_text):\r\n            self.show_and_load_recording()\r\n            self.start_again()\r\n\r\n    def show_and_load_recording(self):\r\n        # Создание курсора\r\n        cur = self.con.cursor()\r\n\r\n        # Получение user_id путем запроса из таблицы Users\r\n        user_id = cur.execute(f\"\"\"\r\n            SELECT user_id FROM Users \r\n                WHERE nickname='{self.user}'\"\"\").fetchall()[0][0]\r\n\r\n        # Получение текущей даты при помощи библиотеки datetime\r\n        data = str(datetime.datetime.now().date())\r\n\r\n        # Получение text_id путем запроса из таблицы Texts\r\n        text_id = cur.execute(f\"\"\"\r\n            SELECT text_id FROM Texts\r\n                WHERE text='{self.generated_text.text()}'\"\"\").fetchall()[0][0]\r\n\r\n        # Получение difficulty_id путем запроса из таблицы Texts\r\n        difficulty_id = cur.execute(f\"\"\"\r\n            SELECT difficulty_id FROM Difficults\r\n                WHERE mode='{self.difficulty_mode}'\"\"\").fetchall()[0][0]\r\n\r\n        # Получение time через self.stopwatch_label.text()\r\n        time = self.stopwatch_label.text()\r\n\r\n        # typing_speed = S / time * 60 сим/мин\r\n        typing_speed = len(self.generated_text.text()) / self.time_r * 60\r\n\r\n        # добавляем запись в бд и показываем результат пользователю\r\n        self.load_recording(user_id, data, text_id, difficulty_id, time, typing_speed)\r\n        self.show_result(time, typing_speed)\r\n\r\n    def load_recording(self, user_id, data, text_id, difficulty_id, time, typing_speed):\r\n        # Создание курсора\r\n        cur = self.con.cursor()\r\n\r\n        que = f\"\"\"INSERT INTO Recordings(user_id, data, text_id, difficulty_id, time, typing_speed) \r\n        VALUES ({user_id}, '{data}', {text_id}, {difficulty_id}, '{time}', {typing_speed})\"\"\"\r\n\r\n        cur.execute(que)\r\n\r\n        self.con.commit()\r\n\r\n    def show_recordings(self):\r\n        recordings_window = RecordingsWindow(self.user, self.theme)\r\n        recordings_window.show()\r\n\r\n    # функция показа результата пользователя\r\n    def show_result(self, time, typing_speed):\r\n        dialog = ResultsDialog(time, typing_speed, self.theme)\r\n        dialog.show()\r\n        dialog.exec()\r\n\r\n    # запуск секундомера\r\n    def start_stopwatch(self):\r\n        self.is_stopwatch_start = True\r\n        self.start_time = time.time()  # в качестве начального времени установить текущее время\r\n        self.time_r = 0  # Обнулить разницу во времени\r\n        self.stopwatch_label.setText('00:00')\r\n        self.stopwatch.start(self.timeInterval)  # запуск секундомера с итервалом timeInterval\r\n\r\n    # сброс секундомера\r\n    def reset_stopwatch(self):\r\n        self.is_stopwatch_start = False\r\n        self.start_time = 0  # в качестве начального времени установить 0\r\n        self.time_r = 0  # Обнулить разницу во времени\r\n        self.stopwatch_label.setText('00:00')\r\n        self.stopwatch.stop()  # остановка секундомера\r\n\r\n    # функция показа значения секундомера\r\n    def show_stopwatch(self):\r\n        # обновить разницу во времени\r\n        self.time_r = int(time.time() - self.start_time)\r\n\r\n        # перевод времени в минуту и секунду\r\n        minutes = self.time_r // 60\r\n        seconds = self.time_r % 60\r\n        if minutes > 59:  # если минут больше чем 59, то вывод максимального времени\r\n            self.timer_label.setText('59:59')\r\n        else:\r\n            # создание строки для удобного показа времени\r\n            minutes = str(minutes)\r\n            seconds = str(seconds)\r\n            stopwatch = '0' * (2 - len(minutes)) + minutes + ':' + '0' * (2 - len(seconds)) + seconds\r\n            self.stopwatch_label.setText(stopwatch)\r\n\r\n    # загрузка пользователей из базы данных в словарь\r\n    def load_users(self):\r\n        # Создание курсора\r\n        cur = self.con.cursor()\r\n\r\n        # Выполнение запроса и получение всех результатов\r\n        users = cur.execute(\"\"\"SELECT user_id, nickname FROM Users\"\"\").fetchall()\r\n\r\n        # если сохраненных пользователей ноль, то пользователь будет Гостем\r\n        if len(users) == 0:\r\n            # добавление в таблицу Users Гостя\r\n            cur.execute(\"INSERT INTO Users(nickname) VALUES('Гость')\")\r\n            # зафиксировать изменения в БД\r\n            self.con.commit()\r\n\r\n    # функция для привязки частей интерфейса к функциям\r\n    def interface_binding(self):\r\n        # настройки темы\r\n        self.dark_theme.triggered.connect(self.set_dark_theme)\r\n        self.light_theme.triggered.connect(self.set_light_theme)\r\n        self.ocean_theme.triggered.connect(self.set_ocean_theme)\r\n        self.violet_theme.triggered.connect(self.set_violet_theme)\r\n        self.pastel_theme.triggered.connect(self.set_pastel_theme)\r\n        self.forest_theme.triggered.connect(self.set_forest_theme)\r\n        self.glamour_theme.triggered.connect(self.set_glamour_theme)\r\n\r\n        # настройки сложности\r\n        self.easy_mode.triggered.connect(lambda: self.change_difficulty('easy'))\r\n        self.normal_mode.triggered.connect(lambda: self.change_difficulty('normal'))\r\n        self.hard_mode.triggered.connect(lambda: self.change_difficulty('hard'))\r\n        self.insane_mode.triggered.connect(lambda: self.change_difficulty('insane'))\r\n\r\n        # настройки пользователя\r\n        self.register_user.triggered.connect(self.registration)\r\n        self.login_user.triggered.connect(self.login)\r\n\r\n        self.results_menu.triggered.connect(self.show_recordings)\r\n\r\n    # функция установки светлой темы\r\n    def set_light_theme(self):\r\n        # если светлая тема еще не установлена\r\n        if self.theme != \"light\":\r\n            self.theme = \"light\"\r\n            self.correct_color = GREEN\r\n            self.incorrect_color = RED\r\n            self.setStyleSheet(\"color: black\")\r\n            self.generated_text.setStyleSheet(f\"color: {BLUE};\")\r\n            self.entered_text.setStyleSheet(f\"color: {GREEN};\")\r\n            self.hint_label.setStyleSheet(f\"color: {GRAY2};\")\r\n            self.stopwatch_label.setStyleSheet(f\"color: {BLUE};\")\r\n            self.username_label.setStyleSheet(f\"color: {BLUE}\")\r\n            self.menubar.setStyleSheet(\"color: black;\")\r\n\r\n    # функция установки темной темы\r\n    def set_dark_theme(self):\r\n        # если темная тема еще не установлена\r\n        if self.theme != \"dark\":\r\n            self.theme = \"dark\"\r\n            self.correct_color = GREEN\r\n            self.incorrect_color = RED\r\n            self.setStyleSheet(f\"background-color: {GRAY1}; color: white;\")\r\n            self.generated_text.setStyleSheet(f\"color: {YELLOW};\")\r\n            self.entered_text.setStyleSheet(f\"color: {GREEN};\")\r\n            self.hint_label.setStyleSheet(f\"color: {GRAY2};\")\r\n            self.stopwatch_label.setStyleSheet(f\"color: {YELLOW};\")\r\n            self.username_label.setStyleSheet(f\"color: {YELLOW  }\")\r\n            self.menubar.setStyleSheet(\"color: white;\")\r\n\r\n    # функция установки океанной темы\r\n    def set_ocean_theme(self):\r\n        # если океанная тема еще не установлена\r\n        if self.theme != \"ocean\":\r\n            self.theme = \"ocean\"\r\n            self.correct_color = OCEAN_GREEN\r\n            self.incorrect_color = OCEAN_RED\r\n            self.setStyleSheet(f\"background-color: {OCEAN_BLUE}; color: white;\")\r\n            self.generated_text.setStyleSheet(f\"color: {OCEAN_YELLOW};\")\r\n            self.entered_text.setStyleSheet(f\"color: {OCEAN_GREEN};\")\r\n            self.hint_label.setStyleSheet(f\"color: {GRAY2};\")\r\n            self.stopwatch_label.setStyleSheet(f\"color: {OCEAN_YELLOW};\")\r\n            self.username_label.setStyleSheet(f\"color: {OCEAN_YELLOW}\")\r\n            self.menubar.setStyleSheet(\"color: white;\")\r\n\r\n    # функция установки сиреневой темы\r\n    def set_pastel_theme(self):\r\n        # если сиреневая тема еще не установлена\r\n        if self.theme != \"pastel\":\r\n            self.theme = \"pastel\"\r\n            self.correct_color = PASTEL_GREEN\r\n            self.incorrect_color = PASTEL_RED\r\n            self.setStyleSheet(f\"background-color: {PASTEL_PURPLE}; color: white;\")\r\n            self.generated_text.setStyleSheet(f\"color: {PASTEL_BLUE};\")\r\n            self.entered_text.setStyleSheet(f\"color: {PASTEL_GREEN};\")\r\n            self.hint_label.setStyleSheet(f\"color: {GRAY2};\")\r\n            self.stopwatch_label.setStyleSheet(f\"color: {PASTEL_BLUE};\")\r\n            self.username_label.setStyleSheet(f\"color: {PASTEL_BLUE}\")\r\n            self.menubar.setStyleSheet(\"color: white;\")\r\n\r\n    # функция установки фиолетовой темы\r\n    def set_violet_theme(self):\r\n        # если фиолетовая тема еще не установлена\r\n        if self.theme != \"violet\":\r\n            self.theme = \"violet\"\r\n            self.correct_color = GREEN\r\n            self.incorrect_color = RED\r\n            self.setStyleSheet(f\"background-color: {PURPLE}; color: white;\")\r\n            self.generated_text.setStyleSheet(f\"color: {YELLOW};\")\r\n            self.entered_text.setStyleSheet(f\"color: {GREEN};\")\r\n            self.hint_label.setStyleSheet(f\"color: {GRAY2};\")\r\n            self.stopwatch_label.setStyleSheet(f\"color: {YELLOW};\")\r\n            self.username_label.setStyleSheet(f\"color: {YELLOW  }\")\r\n            self.menubar.setStyleSheet(\"color: white;\")\r\n\r\n    # функция установки лесной темы\r\n    def set_forest_theme(self):\r\n        # если лесная тема еще не установлена\r\n        if self.theme != \"forest\":\r\n            self.theme = \"forest\"\r\n            self.correct_color = FOREST_LIGHT_GREEN\r\n            self.incorrect_color = FOREST_RED\r\n            self.setStyleSheet(f\"background-color: {FOREST_GREEN}; color: white;\")\r\n            self.generated_text.setStyleSheet(f\"color: {FOREST_BROWN};\")\r\n            self.entered_text.setStyleSheet(f\"color: {FOREST_LIGHT_GREEN};\")\r\n            self.hint_label.setStyleSheet(f\"color: {GRAY2};\")\r\n            self.stopwatch_label.setStyleSheet(f\"color: {FOREST_BROWN};\")\r\n            self.username_label.setStyleSheet(f\"color: {FOREST_BROWN}\")\r\n            self.menubar.setStyleSheet(\"color: white;\")\r\n\r\n    # функция установки гламурной темы\r\n    def set_glamour_theme(self):\r\n        # если гламурная тема еще не установлена\r\n        if self.theme != \"glamour\":\r\n            self.theme = \"glamour\"\r\n            self.setStyleSheet(f\"background-color: {GLAMOUR_PINK}; color: white;\")\r\n            self.generated_text.setStyleSheet(f\"color: white;\")\r\n            self.entered_text.setStyleSheet(f\"color: {GLAMOUR_BLUE};\")\r\n            self.hint_label.setStyleSheet(f\"color: {GLAMOUR_GRAY};\")\r\n            self.stopwatch_label.setStyleSheet(f\"color: white;\")\r\n            self.username_label.setStyleSheet(f\"color: white\")\r\n            self.menubar.setStyleSheet(\"color: white;\")\r\n\r\n    # функция изменения сложности\r\n    def change_difficulty(self, diff):\r\n        # если сложность не осталось такой же, то поменять текст в generated_text со сложностью diff\r\n        if self.difficulty_mode != diff:\r\n            self.load_text(diff)\r\n        # изменить сложность\r\n        self.difficulty_mode = diff\r\n\r\n    # функция регистраций пользователя\r\n    def registration(self):\r\n        # вызов диалогового окна\r\n        username, ok_pressed = QInputDialog.getText(self, \"Регистрация\", \"Введите имя пользователя:\")\r\n\r\n        # если пользователь нажал на ОК, то добавить его в таблицу Users в БД\r\n        if ok_pressed:\r\n            # если пользователь уже существует, то вызвать окно с ошибкой\r\n            cur = self.con.cursor()\r\n            users_id = map(lambda x: x[0], cur.execute(\"\"\"SELECT nickname FROM Users\"\"\").fetchall())\r\n            if username in users_id:\r\n                error_message = QMessageBox(self)\r\n                error_message.setIcon(QMessageBox.Critical)\r\n                error_message.setText(\"Пользователь уже существует!\")\r\n                error_message.setInformativeText(\"Введите другое имя пользователя\")\r\n                error_message.setWindowTitle(\"Регистрация отменена\")\r\n                error_message.exec_()\r\n                return\r\n\r\n            # поменять пользователя\r\n            self.user = username\r\n            # изменить ник отображаемый в окне\r\n            self.username_label.setText(username)\r\n\r\n            # добавляем пользователя в таблицу Users из БД\r\n            cur.execute(f\"INSERT INTO Users(nickname) VALUES('{username}')\")\r\n\r\n            # зафиксировать изменения в БД\r\n            self.con.commit()\r\n\r\n    # функция для входа в пользователя\r\n    def login(self):\r\n        cur = self.con.cursor()\r\n\r\n        # получение ника для входа\r\n        users_id = map(lambda x: x[0], cur.execute(\"\"\"SELECT nickname FROM Users\"\"\").fetchall())\r\n\r\n        username, ok_pressed = QInputDialog.getItem(self, \"Вход\", \"Выберите пользователя: \",\r\n                                                    users_id, 1, False)\r\n        # если пользователь нажал на ОК, то сменить пользователя\r\n        if ok_pressed:\r\n            self.user = username  # смена пользователя\r\n            # изменить ник отображаемый в окне\r\n            self.username_label.setText(username)\r\n\r\n    # функция, которая вызывается, когда закрывается окно\r\n    def closeEvent(self, *args, **kwargs):\r\n        # Закрытие соединение с базой данных при закрытие окна\r\n        self.con.close()\r\n\r\n\r\nclass ResultsDialog(QDialog, Ui_Dialog):\r\n    def __init__(self, time, result, theme):\r\n        QDialog.__init__(self)  # конструктор родительского класса\r\n        # Вызываем метод для загрузки интерфейса из класса Ui_MainWindow,\r\n        self.setupUi(self)\r\n        # изменение темы на тему основного окна\r\n        self.change_theme(theme)\r\n        self.button_box.accepted.connect(self.accept_data)  # привязка функции кнопки ОК\r\n\r\n        self.time_label.setText(f\"Общее время: {time}\")\r\n        self.cpm_label.setText(f\"Символов в минуту: {result:.{1}f}\")\r\n        # if result < 100:\r\n        #     img = \"image1.jpg\"\r\n        # elif 100 <= result < 170:\r\n        #     img = \"image2.jpg\"\r\n        # elif 170 <= result < 250:\r\n        #     img = \"image3.jpg\"\r\n        # elif 250 <= result <= 350:\r\n        #     img = \"image4.jpg\"\r\n        # else:\r\n        #     img = \"image5.jpg\"\r\n        # # try:\r\n        # #     pixmap = QPixmap(img)\r\n        # # except Exception:\r\n        # #     raise FileNotFoundError(\"Файлы с изображениями не найдены\")\r\n        # pixmap = QPixmap(img)\r\n        # self.image_label.setPixmap(pixmap)  # вставка картинки в label\r\n\r\n    # функция для закрытия окна на нажатие ОК\r\n    def accept_data(self):\r\n        self.close()\r\n\r\n    def change_theme(self, theme):\r\n        if theme == \"dark\":\r\n            self.setStyleSheet(f\"background-color: {GRAY1}; color: {YELLOW}\")\r\n        elif theme == \"light\":\r\n            self.setStyleSheet(f\"background-color: white; color: {BLUE}\")\r\n        elif theme == \"ocean\":\r\n            self.setStyleSheet(f\"background-color: {OCEAN_BLUE}; color: {OCEAN_YELLOW}\")\r\n        elif theme == \"pastel\":\r\n            self.setStyleSheet(f\"background-color: white; color: {PASTEL_BLUE}\")\r\n        elif theme == \"violet\":\r\n            self.setStyleSheet(f\"background-color: {PURPLE}; color: {YELLOW}\")\r\n        elif theme == \"forest\":\r\n            self.setStyleSheet(f\"background-color: {FOREST_GREEN}; color: {FOREST_BROWN}\")\r\n        elif theme == \"glamour\":\r\n            self.setStyleSheet(f\"background-color: {GLAMOUR_PINK}; color: white\")\r\n\r\n\r\nif __name__ == '__main__':\r\n    # Создание класса приложения PyQT\r\n    app = QApplication(sys.argv)\r\n    # создание экземпляра класса MyWidget\r\n    ex = MyWidget()\r\n    # показ экземпляра\r\n    ex.show()\r\n    # при завершение исполнения QApplication завершить программу\r\n    sys.exit(app.exec())
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 0a51560dafba9d7d53749bcf082c64b8cd21ab05)
+++ b/main.py	(date 1641798764806)
@@ -335,8 +335,8 @@
         self.con.commit()
 
     def show_recordings(self):
-        recordings_window = RecordingsWindow(self.user, self.theme)
-        recordings_window.show()
+        self.recordings_window = RecordingsWindow(self.user, self.theme)
+        self.recordings_window.show()
 
     # функция показа результата пользователя
     def show_result(self, time, typing_speed):
